package service

import (
	"errors"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
	"time"

	merlin "github.com/gojek/merlin/client"
	mlp "github.com/gojek/mlp/client"
	"github.com/gojek/turing/api/turing/service/mocks"

	"github.com/gojek/turing/api/turing/config"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/gojek/turing/api/turing/models"
	"github.com/jinzhu/gorm"
	"gotest.tools/assert"
)

var expectedAlertContent = strings.Join([]string{
	`groups:`,
	`- name: env_team_service_throughput`,
	`  rules:`,
	`  - alert: service_throughput_violation_env`,
	`    expr: |`,
	`      sum(rate(revision_request_count{`,
	`        environment=\"env\",`,
	`        service_name=~\"service-[0-9]*\"`,
	`      }[5m])) \u003c 50.000000`,
	`    for: 5m`,
	`    labels:`,
	`      owner: team`,
	`      service_name: service`,
	`      severity: warning`,
	`    annotations:`,
	`      dashboard: https://example.com/dashboard?var-environment=test-environment\u0026var-cluster=test-cluster\u0026var-project=test-project\u0026var-router=test-router\u0026var-revision=$__all`, // nolint: lll
	`      description: 'throughput for the past 5m: {{ $value }}rps'`,
	`      playbook: https://example.com`,
	`      summary: 'throughput is lower than the threshold: 50rps'`,
	`  - alert: service_throughput_violation_env`,
	`    expr: |`,
	`      sum(rate(revision_request_count{`,
	`        environment=\"env\",`,
	`        service_name=~\"service-[0-9]*\"`,
	`      }[5m])) \u003c 25.000000`,
	`    for: 5m`,
	`    labels:`,
	`      owner: team`,
	`      service_name: service`,
	`      severity: critical`,
	`    annotations:`,
	`      dashboard: https://example.com/dashboard?var-environment=test-environment\u0026var-cluster=test-cluster\u0026var-project=test-project\u0026var-router=test-router\u0026var-revision=$__all`, // nolint: lll
	`      description: 'throughput for the past 5m: {{ $value }}rps'`,
	`      playbook: https://example.com`,
	`      summary: 'throughput is lower than the threshold: 25rps'\n`,
}, "\\n")

func TestGitlabOpsAlertServiceSave(t *testing.T) {
	mockGitlab, requestRecords := newMockGitlabServer()
	defer mockGitlab.Close()

	mockMLPService := &mocks.MLPService{}

	mockDb, mockSQL := newMockSQL(t)
	defer mockDb.Close()

	mockSQL.ExpectBegin()
	mockSQL.
		ExpectQuery(`INSERT INTO "alerts"`).
		WithArgs(time.Unix(1593647218, 0), time.Unix(1593647219, 0), "env", "team",
			"service", "throughput", float64(50), float64(25), "5m").
		WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(1))
	mockSQL.ExpectCommit()
	mockSQL.
		ExpectQuery(`SELECT (.+) FROM "alerts"`).
		WithArgs(1).
		WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(1))

	service, err := NewGitlabOpsAlertService(
		mockDb,
		mockMLPService,
		config.AlertConfig{
			Enabled: true,
			GitLab: &config.GitlabConfig{
				BaseURL:    mockGitlab.URL,
				Token:      "token",
				ProjectID:  "project",
				Branch:     "master",
				PathPrefix: "prefix",
			},
			PlaybookURL: "https://example.com",
			DashboardURLTemplate: "https://example.com/dashboard?var-environment={{ .Environment }}" +
				"&var-cluster={{ .Cluster }}&var-project={{ .Project }}&var-router={{ .Router }}&var-revision={{ .Revision }}",
		})
	assert.NilError(t, err)

	alert := models.Alert{
		Model: models.Model{
			CreatedAt: time.Unix(1593647218, 0),
			UpdatedAt: time.Unix(1593647219, 0),
		},
		Environment:       "env",
		Team:              "team",
		Service:           "service",
		Metric:            models.MetricThroughput,
		WarningThreshold:  50,
		CriticalThreshold: 25,
		Duration:          "5m",
	}

	router := models.Router{
		ProjectID:       1,
		EnvironmentName: "test-environment",
		Name:            "test-router",
	}

	mockMLPService.On("GetEnvironment", "test-environment").Return(&merlin.Environment{Cluster: "test-cluster"}, nil)
	mockMLPService.On("GetProject", 1).Return(&mlp.Project{Name: "test-project"}, nil)

	_, err = service.Save(alert, router, "user@gojek.com")
	assert.NilError(t, err)

	err = mockSQL.ExpectationsWereMet()
	assert.NilError(t, err)

	expectedReq := "POST /api/v4/projects/project/repository/files/prefix/env/team/service/throughput.yaml"
	expectedReqBody := fmt.Sprintf(
		`{"branch":"master","author_email":"user@gojek.com","content":"%s",`+
			`"commit_message":"Autogenerated alert for service: service, team: team, environment: env"}`,
		expectedAlertContent)
	reqBody, ok := requestRecords[expectedReq]
	assert.Check(t, ok == true, "Request: %s is not called. Actual requests: %v", expectedReq, requestRecords)
	assert.Check(t, reqBody == expectedReqBody, "Expected: %s, \nActual: %s", expectedReqBody, reqBody)
}

func TestGitlabOpsAlertServiceSaveShouldRevertGitWhenDbFail(t *testing.T) {
	mockGitlab, requestRecords := newMockGitlabServer()
	defer mockGitlab.Close()

	mockMLPService := &mocks.MLPService{}

	mockDb, mockSQL := newMockSQL(t)
	defer mockDb.Close()

	mockSQL.ExpectBegin()
	mockSQL.
		ExpectQuery(`INSERT INTO "alerts"`).
		WillReturnError(errors.New("insertion error"))

	service, err := NewGitlabOpsAlertService(
		mockDb,
		mockMLPService,
		config.AlertConfig{
			Enabled: true,
			GitLab: &config.GitlabConfig{
				BaseURL:    mockGitlab.URL,
				Token:      "token",
				ProjectID:  "project",
				Branch:     "master",
				PathPrefix: "prefix",
			},
			PlaybookURL: "https://example.com",
		})
	assert.NilError(t, err)

	alert := models.Alert{
		Environment: "env",
		Team:        "team",
		Service:     "service",
		Metric:      models.MetricThroughput,
		Duration:    "5m",
	}

	router := models.Router{
		ProjectID:       1,
		EnvironmentName: "test-environment",
		Name:            "test-router",
	}

	mockMLPService.On("GetEnvironment", "test-environment").Return(&merlin.Environment{Cluster: "test-cluster"}, nil)
	mockMLPService.On("GetProject", 1).Return(&mlp.Project{Name: "test-project"}, nil)

	_, err = service.Save(alert, router, "user@gojek.com")
	assert.ErrorContains(t, err, "insertion error")

	expected := "DELETE /api/v4/projects/project/repository/files/prefix/env/team/service/throughput.yaml"
	_, ok := requestRecords[expected]
	assert.Check(t, ok == true, "Request: %s is not called. Actual requests: %v", expected, requestRecords)
}

func TestGitlabOpsAlertServiceList(t *testing.T) {
	mockDb, mockSQL := newMockSQL(t)
	defer mockDb.Close()

	mockMLPService := &mocks.MLPService{}

	columns := []string{"environment", "team", "service", "metric", "duration"}
	mockSQL.
		ExpectQuery(`SELECT (.+) FROM "alerts"`).
		WithArgs("service").
		WillReturnRows(sqlmock.NewRows(columns).AddRow("env", "team", "service", "throughput", "5m"))

	service, err := NewGitlabOpsAlertService(
		mockDb,
		mockMLPService,
		config.AlertConfig{
			Enabled: true,
			GitLab: &config.GitlabConfig{
				Token:      "token",
				ProjectID:  "project",
				Branch:     "master",
				PathPrefix: "prefix",
			},
			PlaybookURL: "https://example.com",
		})
	assert.NilError(t, err)

	alerts, err := service.List("service")
	assert.NilError(t, err)
	assert.Equal(t, len(alerts), 1)
	assert.DeepEqual(t, alerts[0],
		&models.Alert{
			Environment: "env",
			Team:        "team",
			Service:     "service",
			Metric:      "throughput",
			Duration:    "5m",
		},
	)

	err = mockSQL.ExpectationsWereMet()
	assert.NilError(t, err)
}

func TestGitlabOpsAlertServiceFindByID(t *testing.T) {
	mockDb, mockSQL := newMockSQL(t)
	defer mockDb.Close()

	mockMLPService := &mocks.MLPService{}

	columns := []string{"environment", "team", "service", "metric", "duration"}
	mockSQL.
		ExpectQuery(`SELECT (.+) FROM "alerts"`).
		WithArgs(5).
		WillReturnRows(sqlmock.NewRows(columns).AddRow("env", "team", "service", "throughput", "5m"))

	service, err := NewGitlabOpsAlertService(
		mockDb,
		mockMLPService,
		config.AlertConfig{
			Enabled: true,
			GitLab: &config.GitlabConfig{
				Token:      "token",
				ProjectID:  "project",
				Branch:     "master",
				PathPrefix: "prefix",
			},
			PlaybookURL: "https://example.com",
		})
	assert.NilError(t, err)

	alert, err := service.FindByID(5)
	assert.NilError(t, err)
	assert.DeepEqual(t, alert,
		&models.Alert{
			Environment: "env",
			Team:        "team",
			Service:     "service",
			Metric:      "throughput",
			Duration:    "5m",
		},
	)

	err = mockSQL.ExpectationsWereMet()
	assert.NilError(t, err)
}

func TestGitlabOpsAlertServiceFindByIDShouldReturnErrWhenNotFound(t *testing.T) {
	mockDb, mockSQL := newMockSQL(t)
	defer mockDb.Close()

	mockMLPService := &mocks.MLPService{}

	mockSQL.
		ExpectQuery(`SELECT (.+) FROM "alerts"`).
		WithArgs(1).
		WillReturnError(errors.New("select not found"))

	service, err := NewGitlabOpsAlertService(
		mockDb,
		mockMLPService,
		config.AlertConfig{
			Enabled: true,
			GitLab: &config.GitlabConfig{
				Token:      "token",
				ProjectID:  "project",
				Branch:     "master",
				PathPrefix: "prefix",
			},
			PlaybookURL: "https://example.com",
		})
	assert.NilError(t, err)

	_, err = service.FindByID(1)
	assert.ErrorContains(t, err, "select not found")
}

func TestGitlabOpsAlertServiceUpdate(t *testing.T) {
	mockGitlab, requestRecords := newMockGitlabServer()
	defer mockGitlab.Close()

	mockMLPService := &mocks.MLPService{}

	mockDb, mockSQL := newMockSQL(t)
	defer mockDb.Close()

	mockSQL.
		ExpectQuery(`SELECT (.+) FROM "alerts"`).
		WithArgs(1).
		WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(1))
	mockSQL.ExpectBegin()
	mockSQL.
		ExpectExec(`UPDATE "alerts"`).
		WithArgs(sqlmock.AnyArg(), "env", "team", "service", "throughput", float64(50), float64(25), "5m", 1).
		WillReturnResult(sqlmock.NewResult(1, 1))
	mockSQL.ExpectCommit()

	service, err := NewGitlabOpsAlertService(
		mockDb,
		mockMLPService,
		config.AlertConfig{
			Enabled: true,
			GitLab: &config.GitlabConfig{
				BaseURL:    mockGitlab.URL,
				Token:      "token",
				ProjectID:  "project",
				Branch:     "master",
				PathPrefix: "prefix",
			},
			PlaybookURL: "https://example.com",
			DashboardURLTemplate: "https://example.com/dashboard?var-environment={{ .Environment }}" +
				"&var-cluster={{ .Cluster }}&var-project={{ .Project }}&var-router={{ .Router }}&var-revision={{ .Revision }}",
		})
	assert.NilError(t, err)

	alert := models.Alert{
		Model:             models.Model{ID: 1},
		Environment:       "env",
		Team:              "team",
		Service:           "service",
		Metric:            models.MetricThroughput,
		WarningThreshold:  50,
		CriticalThreshold: 25,
		Duration:          "5m",
	}

	router := models.Router{
		ProjectID:       1,
		EnvironmentName: "test-environment",
		Name:            "test-router",
	}

	mockMLPService.On("GetEnvironment", "test-environment").Return(&merlin.Environment{Cluster: "test-cluster"}, nil)
	mockMLPService.On("GetProject", 1).Return(&mlp.Project{Name: "test-project"}, nil)

	err = service.Update(alert, router, "user@gojek.com")
	assert.NilError(t, err)

	err = mockSQL.ExpectationsWereMet()
	assert.NilError(t, err)

	expectedReq := "PUT /api/v4/projects/project/repository/files/prefix/env/team/service/throughput.yaml"
	expectedReqBody := fmt.Sprintf(
		`{"branch":"master","author_email":"user@gojek.com","content":"%s",`+
			`"commit_message":"Autogenerated alert for service: service, team: team, environment: env"}`,
		expectedAlertContent)
	reqBody, ok := requestRecords[expectedReq]
	assert.Check(t, ok == true, "Request: %s is not called. Actual requests: %v", expectedReq, requestRecords)
	assert.Check(t, reqBody == expectedReqBody, "Expected: %s, \nActual: %s", expectedReqBody, reqBody)
}

func TestGitlabOpsAlertServiceUpdateShouldRevertGitWhenDbFail(t *testing.T) {
	mockGitlab, requestRecords := newMockGitlabServer()
	defer mockGitlab.Close()

	mockMLPService := &mocks.MLPService{}

	mockDb, mockSQL := newMockSQL(t)
	defer mockDb.Close()

	mockSQL.
		ExpectQuery(`SELECT (.+) FROM "alerts"`).
		WithArgs(1).
		WillReturnRows(
			sqlmock.
				NewRows([]string{"id", "environment", "team", "service", "metric"}).
				AddRow(1, "env", "team", "service", models.MetricLatency95p),
		)
	mockSQL.ExpectBegin()
	mockSQL.
		ExpectExec(`UPDATE "alerts"`).
		WillReturnError(errors.New("update error"))

	service, err := NewGitlabOpsAlertService(
		mockDb,
		mockMLPService,
		config.AlertConfig{
			Enabled: true,
			GitLab: &config.GitlabConfig{
				BaseURL:    mockGitlab.URL,
				Token:      "token",
				ProjectID:  "project",
				Branch:     "master",
				PathPrefix: "prefix",
			},
			PlaybookURL: "https://example.com",
			DashboardURLTemplate: "https://example.com/dashboard?var-environment={{ .Environment }}" +
				"&var-cluster={{ .Cluster }}&var-project={{ .Project }}&var-router={{ .Router }}&var-revision={{ .Revision }}",
		})
	assert.NilError(t, err)

	alert := models.Alert{
		Model:       models.Model{ID: 1},
		Environment: "env",
		Team:        "team",
		Service:     "service",
		Metric:      models.MetricThroughput,
		Duration:    "5m",
	}

	router := models.Router{
		ProjectID:       1,
		EnvironmentName: "test-environment",
		Name:            "test-router",
		CurrRouterVersion: &models.RouterVersion{
			Version: 2,
		},
	}

	mockMLPService.On("GetEnvironment", "test-environment").Return(&merlin.Environment{Cluster: "test-cluster"}, nil)
	mockMLPService.On("GetProject", 1).Return(&mlp.Project{Name: "test-project"}, nil)

	err = service.Update(alert, router, "user@gojek.com")
	assert.ErrorContains(t, err, "update error")

	expected := "PUT /api/v4/projects/project/repository/files/prefix/env/team/service/throughput.yaml"
	_, ok := requestRecords[expected]
	assert.Check(t, ok == true, "Request: %s is not called. Actual requests: %v", expected, requestRecords)

	expected = "PUT /api/v4/projects/project/repository/files/prefix/env/team/service/latency95p.yaml"
	_, ok = requestRecords[expected]
	assert.Check(t, ok == true, "Request: %s is not called. Actual requests: %v", expected, requestRecords)
}

func TestGitlabOpsAlertSeviceDelete(t *testing.T) {
	mockGitlab, requestRecords := newMockGitlabServer()
	defer mockGitlab.Close()

	mockMLPService := &mocks.MLPService{}

	mockDb, mockSQL := newMockSQL(t)
	defer mockDb.Close()

	mockSQL.
		ExpectQuery(`SELECT (.+) FROM "alerts"`).
		WithArgs(1).
		WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(1))
	mockSQL.ExpectBegin()
	mockSQL.
		ExpectExec(`DELETE FROM "alerts"`).
		WithArgs(1).
		WillReturnResult(sqlmock.NewResult(1, 1))
	mockSQL.ExpectCommit()

	service, err := NewGitlabOpsAlertService(
		mockDb,
		mockMLPService,
		config.AlertConfig{
			Enabled: true,
			GitLab: &config.GitlabConfig{
				BaseURL:    mockGitlab.URL,
				Token:      "token",
				ProjectID:  "project",
				Branch:     "master",
				PathPrefix: "prefix",
			},
			PlaybookURL: "https://example.com",
		})
	assert.NilError(t, err)

	alert := models.Alert{
		Model: models.Model{
			ID: 1,
		},
		Environment: "env",
		Team:        "team",
		Service:     "service",
		Metric:      models.MetricLatency95p,
		Duration:    "5m",
	}

	router := models.Router{
		ProjectID:       1,
		EnvironmentName: "test-environment",
		Name:            "test-router",
		CurrRouterVersion: &models.RouterVersion{
			Version: 2,
		},
	}

	err = service.Delete(alert, router, "user@gojek.com")
	assert.NilError(t, err)

	err = mockSQL.ExpectationsWereMet()
	assert.NilError(t, err)

	expected := "DELETE /api/v4/projects/project/repository/files/prefix/env/team/service/latency95p.yaml"
	_, ok := requestRecords[expected]
	assert.Check(t, ok == true, "Request: %s is not called. Actual requests: %v", expected, requestRecords)
}

func TestGitlabOpsAlertSeviceDeleteShouldRevertGitWhenDbFail(t *testing.T) {
	mockGitlab, requestRecords := newMockGitlabServer()
	defer mockGitlab.Close()

	mockMLPService := &mocks.MLPService{}

	mockDb, mockSQL := newMockSQL(t)
	defer mockDb.Close()

	mockSQL.
		ExpectQuery(`SELECT (.+) FROM "alerts"`).
		WithArgs(1).
		WillReturnRows(
			sqlmock.
				NewRows([]string{"id", "environment", "team", "service", "metric"}).
				AddRow(1, "env", "team", "service", models.MetricLatency95p),
		)
	mockSQL.ExpectBegin()
	mockSQL.
		ExpectExec(`DELETE FROM "alerts"`).
		WillReturnError(errors.New("delete error"))

	service, err := NewGitlabOpsAlertService(
		mockDb,
		mockMLPService,
		config.AlertConfig{
			Enabled: true,
			GitLab: &config.GitlabConfig{
				BaseURL:    mockGitlab.URL,
				Token:      "token",
				ProjectID:  "project",
				Branch:     "master",
				PathPrefix: "prefix",
			},
			PlaybookURL: "https://example.com",
		})
	assert.NilError(t, err)

	alert := models.Alert{
		Model:       models.Model{ID: 1},
		Environment: "env",
		Team:        "team",
		Service:     "service",
		Metric:      models.MetricLatency95p,
		Duration:    "5m",
	}

	router := models.Router{
		ProjectID:       1,
		EnvironmentName: "test-environment",
		Name:            "test-router",
		CurrRouterVersion: &models.RouterVersion{
			Version: 2,
		},
	}

	mockMLPService.On("GetEnvironment", "test-environment").Return(&merlin.Environment{Cluster: "test-cluster"}, nil)
	mockMLPService.On("GetProject", 1).Return(&mlp.Project{Name: "test-project"}, nil)

	err = service.Delete(alert, router, "user@gojek.com")
	assert.ErrorContains(t, err, "delete error")

	expected := "DELETE /api/v4/projects/project/repository/files/prefix/env/team/service/latency95p.yaml"
	_, ok := requestRecords[expected]
	assert.Check(t, ok == true, "Request: %s is not called. Actual requests: %v", expected, requestRecords)

	expected = "POST /api/v4/projects/project/repository/files/prefix/env/team/service/latency95p.yaml"
	_, ok = requestRecords[expected]
	assert.Check(t, ok == true, "Request: %s is not called. Actual requests: %v", expected, requestRecords)
}

func newMockGitlabServer() (mockGitlab *httptest.Server, requestRecords map[string]string) {
	records := make(map[string]string)
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		record := fmt.Sprintf("%s %s", r.Method, r.URL.Path)
		body, err := ioutil.ReadAll(r.Body)
		if body != nil && err == nil {
			records[record] = string(body)
		} else {
			records[record] = ""
		}

		if strings.HasPrefix(r.URL.Path, "/api/v4/projects/project/repository/files/") && r.Method != http.MethodGet {
			fmt.Fprintf(w, `{"file_path":"file_path.yaml","branch":"master"}`)
		} else {
			fmt.Fprintf(w, "")
		}
	}))
	return server, records
}

func newMockSQL(t *testing.T) (*gorm.DB, sqlmock.Sqlmock) {
	mockdb, mocksql, err := sqlmock.New()
	if err != nil {
		t.Fatalf("failed to open stub database connection: %s", err)
	}
	gormDb, err := gorm.Open("postgres", mockdb)
	if err != nil {
		t.Fatalf("failed to open go-orm database connection: %s", err)
	}
	return gormDb, mocksql
}
